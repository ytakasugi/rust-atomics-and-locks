# 第7章 プロセッサーを理解する

第2章と第3章の理論は、正しい並行コードを書くために必要なものですが、さらに、プロセッサレベルで実際に何が行われているのかをおおよそ理解することも非常に有効です。本章では、アトミック演算をコンパイルするマシン命令、プロセッサ・アーキテクチャの違い、弱いバージョンの`compare_exchange`が存在する理由、個々の命令の最下層におけるメモリ順序の意味、そしてキャッシングがこれらとどう関係しているのかを探ります。

この章の目的は、すべてのプロセッサ・アーキテクチャの関連する詳細をすべて理解することではありません。そのためには、本棚いっぱいの本が必要で、その多くはおそらく未執筆か公開されていないでしょう。その代わり、本章の目標は、アトミックがプロセッサレベルでどのように機能するかについての一般的な考え方を身につけ、アトミックを含むコードを実装し最適化する際に、より多くの情報に基づいた意思決定を行えるようにすることです。そしてもちろん、舞台裏で何が起こっているのかという好奇心を満たすため、抽象的な理論から一旦離れることでもあります。

ここでは、できるだけ具体的に説明するために、2つのプロセッサ・アーキテクチャに焦点を当てます：

x86-64:
x86-64：ノートパソコン、デスクトップパソコン、サーバー、ゲーム機などの大半で使用されているIntelとAMDのプロセッサが実装するx86アーキテクチャの64ビット版です。元々16ビットのx86アーキテクチャとその非常に人気のある32ビット拡張はインテルによって開発されましたが、現在x86-64と呼ばれている64ビット版は、当初AMDによって開発された拡張で、しばしばAMD64と呼ばれています。インテルも独自の64ビットアーキテクチャであるIA-64を開発したが、結局はAMDのより人気のあるx86拡張機能を採用した（IA-32e、EM64T、後にIntel 64という名称になる）。

ARM64：
ARMアーキテクチャの64ビット版で、ほぼすべての最新モバイル機器、高性能組み込みシステム、そして最近のノートパソコンやデスクトップパソコンで使用されるようになってきています。AArch64とも呼ばれ、ARMv8の一部として導入された。ARMの初期バージョン（32ビット）は、多くの点で類似していますが、さらに幅広いアプリケーションで使用されています。自動車から電子COVID検査まで、想像できるあらゆる種類の組み込みシステムで人気のあるマイクロコントローラの多くは、ARMv6とARMv7をベースにしています。

この2つのアーキテクチャは、多くの点で似て非なるものです。最も重要なのは、アトミックに対するアプローチが異なることです。この2つのアーキテクチャでアトミックがどのように動作するかを理解することで、他の多くのアーキテクチャに適用できる、より一般的な理解を得ることができます。

## プロセッサの命令

コンパイラの出力、つまりプロセッサが実行する正確な命令をよく観察することで、プロセッサレベルでどのように動作するかをおおよそ理解することができます。

---

### Note

アセンブリの簡単な紹介
RustやC言語などのコンパイル言語で書かれたソフトウェアをコンパイルする場合、そのコードは、最終的にプログラムを実行するプロセッサが実行できる機械命令に変換されます。これらの命令は、プログラムをコンパイルするプロセッサのアーキテクチャに非常に固有です。

機械語コードとも呼ばれるこれらの命令は、バイナリ形式で符号化されており、私たち人間には全く読めません。アセンブリは、これらの命令を人間が読むことができるように表現したものです。すべての命令は1行のテキストで表現され、通常は命令を識別するための1つの単語または頭文字で始まり、その後に引数またはオペランドが続く。アセンブラは、テキスト表現をバイナリ表現に変換し、逆アセンブラはその逆を行います。

Rustのような言語からコンパイルした後、元のソースコードの構造のほとんどはなくなってしまいます。最適化のレベルによっては、関数や関数呼び出しはまだ認識できるかもしれません。しかし、構造体や列挙型などの型はバイトとアドレスに縮小され、ループや条件分岐は基本的なジャンプ命令や分岐命令を含む平面構造に縮小されています。

ここで、あるアーキテクチャのプログラムのごく一部のアセンブリのスニペットを見てみましょう：

```text
ldr x, 1234 // load from memory address 1234 into x
li y, 0     // set y to zero
inc x       // increment x
add y, x    // add x to y
mul x, 3    // multiply x by 3
cmp y, 10   // compare y to 10
jne -5      // jump five instructions back if not equal
str 1234, x // store x to memory address 1234
```

この例では、xとyはレジスタの名前です。レジスタはメインメモリではなくプロセッサの一部であり、通常は1つの整数またはメモリアドレスを保持します。64ビットアーキテクチャでは、一般に64ビットの大きさです。レジスタの数はアーキテクチャによって異なりますが、通常は非常に限られています。レジスタは基本的に計算の一時的なスクラッチパッドとして使用され、メモリに保存する前に中間的な結果を保存する場所として使用されます。

上の例の1234と-5のように、特定のメモリアドレスを指す定数は、多くの場合、より人間が読みやすいラベルに置き換えられます。アセンブラは、アセンブリをバイナリ・マシンコードに変換する際に、これらを実際のアドレスに自動的に置き換えます。

ラベルを使用すると、先ほどの例は次のようになります：

```text
         ldr x, SOME_VAR
         li y, 0
my_loop: inc x
         add y, x
         mul x, 3
         cmp y, 10
         jne my_loop
         str SOME_VAR, x
```

ラベルの名前はアセンブリの一部でしかなく、バイナリのマシンコードの一部ではないので、逆アセンブラは元々どんなラベルが使われていたかを知らず、ほとんどの場合、label1やvar2といった意味のない生成名を使うだけでしょう。

すべての異なるアーキテクチャのアセンブリに関する完全なコースは、本書の範囲外ですが、この章を読むための前提条件ではありません。アセンブリを書くのではなく、アセンブリを読むだけなので、ごく一般的な理解で例を理解するには十分すぎるほどです。各例題の関連指示は、アセンブリの経験がなくてもフォローできるように、十分に詳細に説明します。

---

Rustコンパイラが生成する正確なマシンコードを見るには、いくつかの選択肢があります。通常通りコードをコンパイルし、ディスアセンブラ（`objdump`など）を使って、生成されたバイナリファイルをアセンブリに戻すことができます。コンパイラがコンパイル時に生成するデバッグ情報を使って、ディスアセンブラはRustソースコードの元の関数名に対応するラベルを生成することができます。この方法の欠点は、コンパイル対象の特定のプロセッサアーキテクチャをサポートする逆アセンブラが必要なことです。Rustコンパイラは多くのアーキテクチャをサポートしていますが、多くの逆アセンブラは、コンパイルされた1つのアーキテクチャしかサポートしていません。

より直接的な方法としては、rustcに`--emit=asm`フラグを指定して、バイナリの代わりにアセンブリを生成するようコンパイラに依頼する方法があります。この方法の欠点は、生成される出力に無関係な行が多く含まれ、必要のないアセンブラやデバッグツールのための情報が含まれていることです。

`cargo-show-asm`のような素晴らしいツールがあり、cargoと統合して、正しいフラグでcrateをコンパイルし、興味のある関数の関連アセンブリを見つけ、実際の命令を含む関連行を強調表示するプロセスを自動化することができます。

比較的小さなスニペットの場合、最も簡単で推奨される方法は、Matt Godboltによる優れたCompiler Explorerのようなウェブサービスを使用することです。このウェブサイトでは、Rustを含む多くの言語でコードを書くことができ、選択したコンパイラのバージョンでコンパイルされた対応するアセンブリを直接見ることができます。最適化後も対応関係がある限り、Rustのどの行とアセンブリのどの行が対応しているかを色分けして表示することもできます。

異なるアーキテクチャのアセンブリを見たいので、Rustコンパイラがコンパイルするターゲットを正確に指定する必要があります。ここでは、x86-64には`x86_64-unknown-linux-musl`を、ARM64には`aarch64-unknown-linux-musl`を使用します。これらはすでにコンパイラエクスプローラで直接サポートされています。ローカルでコンパイルする場合、例えば`cargo-show-asm`や上記の他の方法を使用する場合、これらのターゲットにRust標準ライブラリがインストールされていることを確認する必要があり、これは通常`rustup target add`を使用して行われます。

どのような場合でも、コンパイルするターゲットは `--target` コンパイラフラグで選択します。例えば、`--target=aarch64-unknown-linux-musl`です。ターゲットを指定しない場合は、現在使用しているプラットフォームが自動的に選択されます。(コンパイラエクスプローラの場合は、それがホストされているプラットフォームで、現在は`x86_64-unknown-linux-gnu`です。)。

さらに、`-O`フラグを有効にすることで最適化が有効になり、オーバーフローのチェックが無効になるため、これから見ていく小さな関数のアセンブリの生成量を大幅に減らすことができるので、最適化を有効にする（Cargoを使う場合は`--release`）ことが推奨されます。

試しに、以下の関数のx86-64とARM64のアセンブリを見てみましょう：

```rust
pub fn add_ten(num: &mut i32) {
    *num += 10;
}
```

上記のいずれかの方法でコンパイラフラグとして`-O --target=aarch64-unknown-linux-musl` を使用すると、ARM64では次のようなアセンブリ出力が得られます：

```text
add_ten:
    ldr w8, [x0]
    add w8, w8, #10
    str w8, [x0]
    ret
```

`x0`レジスタには、関数の引数である`num`、つまり10ずつインクリメントするi32のアドレスが格納されています。まず、`ldr`命令でそのメモリアドレスから32ビット値を`w8`レジスタにロードします。そして、`add`命令で`w8`に10を加算し、その結果を`w8`に格納し直します。そして、その後、`str`命令で`w8`レジスタを同じメモリアドレスに戻して格納します。最後に、`ret`命令で関数の終わりを示し、プロセッサがジャンプバックして`add_ten`を呼び出した関数を続行するようにします。

全く同じコードを`x86_64-unknown-linux-musl`用にコンパイルすると、代わりに次のようなものが得られます：

```text
add_ten:
    add dword ptr [rdi], 10
    ret
```

今回は、`num`の引数に`rdi`というレジスタが使われています。さらに興味深いことに、x86-64では、ARM64では3命令必要な値のロード、インクリメント、ストアを、1つの`add`命令で行うことができます。

これは、x86のようなCISC（Complex Instruction Set Computer）アーキテクチャの場合、通常、このようなことが起こります。このようなアーキテクチャの命令は、レジスタを操作したり、あるサイズのメモリを直接操作したりと、多くのバリエーションがあることが多い。(アセンブリの`dword`は32ビット演算を指定する)。

これに対して、ARMのような縮小命令セットコンピュータ（RISC）アーキテクチャでは、通常、非常に少ないバリエーションでよりシンプルな命令セットを持ちます。ほとんどの命令はレジスタに対してのみ動作可能で、メモリへのロードとストアは別の命令を必要とする。このため、プロセッサをよりシンプルにすることができ、コストの削減や、場合によっては性能の向上を実現することができます。

この違いは、特にアトミックフェッチ＆モディファイ命令で顕著に現れます。

---

### Note

コンパイラは一般的に非常に賢いのですが、特にアトミック演算が含まれる場合、常に最適なアセンブリを生成するわけではありません。もしあなたが実験をしていて、アセンブリの一見不必要な複雑さに戸惑うようなケースを見つけたら、それはコンパイラの将来のバージョンに最適化の機会があることを意味することが多いのです。

---

## Load and Store

より高度な内容を説明する前に、まず最も基本的なアトミック操作であるロードとストアに使用される命令について見てみましょう。

以下のように、x86-64とARM64の両方で、`&mut i32`を介した通常の非アトミックストアは、たった1命令で完了します：

- Rust Source

```rust
pub fn a(x: &mut i32) {
    *x = 0;
}
```

- Compiled x86-64

```text
a:
    mov dword ptr [rdi], 0
    ret
```

- Compiled ARM64

```text
a:
    str wzr, [x0]
    ret
```

x86-64では、非常に汎用性の高いmov命令を使用して、データをある場所から別の場所にコピー（「move」）します。この場合、ゼロ定数からメモリにコピーします。ARM64では、32ビットレジスタをメモリに格納するためにstr（store register）命令を使用します。この場合、常にゼロを含む特別な`wzr`レジスタが使用されます。

代わりに`AtomicI32`へのリラックスしたアトミックストアを使用するようにコードを変更すると、次のようになります：

- Rust Source

```rust
pub fn a(x: &AtomicI32) {
    x.store(0, Relaxed);
}
```

- Compiled x86-64

```text
a:
    mov dword ptr [rdi], 0
    ret
```

- Compiled ARM64

```text
a:
    str wzr, [x0]
    ret
```

やや意外かもしれないが、アセンブリは非アトミックバージョンと同じである。結局のところ、`mov`命令と`str`命令はすでにアトミックだったのです。発生するか、まったく発生しないかのどちらかであった。どうやら、ここでの`&mut i32`と`&AtomicI32`の違いは、コンパイラのチェックと最適化にのみ関係し、プロセッサにとっては無意味であるようです-少なくとも、この2つのアーキテクチャでのリラックスしたストア操作においては。

同じことが、緩和されたロード操作について見るときにも起こります：

### 非アトミックロード

- Rust Source

```rust
pub fn a(x: &i32) -> i32 {
    *x
}
```

- Compiled x86-64

```text
a:
    mov eax, dword ptr [rdi]
    ret
```

- Compiled ARM64

```text
a:
    ldr w0, [x0]
    ret
```

### アトミックロード

- Rust Source

```rust
pub fn a(x: &AtomicI32) -> i32 {
    x.load(Relaxed)
}
```

- Compiled x86-64

```text
a:
    mov eax, dword ptr [rdi]
    ret
```

- Compiled ARM64

```text
a:
    ldr w0, [x0]
    ret
```

x86-64では、`mov`命令が再び使用され、今度はメモリから32ビット`eax`レジスタにコピーされる。ARM64では、`ldr`（load register）命令を使用して、メモリから`w0`レジスタに値をロードします。

---

### Note

32ビットの`eax`と`w0`レジスタは、関数の32ビット戻り値の受け渡しに使用します。(64ビット値の場合は、64ビットの`rax`、`x0`レジスタを使用します)。

---

プロセッサは、アトミックストアと非アトミックロードを区別していないようですが、Rustのコードでは、この違いを無視することはできません。Rust コンパイラは、&mut i32 を使用する場合、他のスレッドが同じ `i32` に同時にアクセスできないことを想定し、ストア操作の結果が対応する 1 つのストア命令にならないようにコードを変換または最適化する可能性があります。たとえば、非アトミック32ビットロードまたはストアが2つの別々の16ビット命令で実行されるのは、やや珍しいものの、完全に正しいことでしょう。

## Read-Modify-Write Operations



![](./images/Fig7-1.svg)
